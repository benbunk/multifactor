<?php
/**
 * @file Implementation of drupal core hooks.
 */

/**
 * Constants
 */
define('MULTIFACTOR_ROLE_AUTHENTICATED_USER_DISABLED',
  variable_get('multifactor_role_authenticated_user_disabled', TRUE));
define('MULTIFACTOR_BRICK_ON_ERROR', variable_get('multifactor_brick_on_error', FALSE));
define('MULTIFACTOR_ROLE_USER_1_FAILOVER', variable_get('multifactor_role_user_1_failover', TRUE));

/**
 * Implementation of hook_form_alter().
 */
function multifactor_form_alter(&$form, $form_state, $form_id) {
  switch ($form_id) {
    case 'user_login':
    case 'user_login_block':
        $form['#validate'][] = 'multifactor_user_login_validate';
      break;
  }
}

/**
 * Implementation of form validate. This functions does more than just validating, but it's main
 * Intention is to break the login form flow.
 *
 * @param $form_item
 *   The status of the name field in the form field after being submitted by the user.
 *
 */
function multifactor_user_login_validate($form, &$form_state) {
  //love u

  // @todo Check which method the user prefers
  /*
   * switch(profile->multifactor_method) {
   *   case 'text': validate_text($form_state); break;
   *   case 'voip': // Fall through...
   *   default: validate_voip($form_state); break;
   * }
   */

  // Load user name from the form field - name.
  $name = $form_state['values']['name'];

// @todo Move loading the user and profile into a separate helper function.
//////////////////////////////////// LOAD USER
  // Is the user blocked
  // Fail silenty if the user is blocked.
  if(user_is_blocked($name)) {
    return;
  }

  // Load the user.
  $user = user_load(array('name' => $name));
  // Fail silenty if the user doesn't exist.
  if(empty($user->uid) || !is_numeric($user->uid)) {
    return;
  }

  // If the user only has the authenticated role and MULTIFACTOR_ROLE_AUTHENTICATED_USER_DISABLED is set to TRUE
  // don't require multifactor authentication.
  if((MULTIFACTOR_ROLE_AUTHENTICATED_USER_DISABLED)
     && (count($user->roles) === 1)
     && ($user->roles[0] === 'authenticated user')) {
    watchdog('multifactor', 'Multifactor: multifactor_role_authenticated_user_disabled is set to TRUE. User has only
            one role and it is the default authenticated user role');
    return;
  }

  // @todo Load profile fields and check pre reqs required for multifactor authentication exits. (text = enabled || pin exists, etc.)
  // Load Profile Data
  profile_load_profile($user);

  // @todo move getting a pin number to a support function in case the field changes or needs to be configurable.
  // Brick the login process if failback isn't enabled or no pre-reqs exist. 
  // @todo we might need to make this brick feature a bit more complex by only applying it to roles that require multifactor.
  if(MULTIFACTOR_BRICK_ON_ERROR
     && (!isset($user->profile_multifactor_pin) || !numeric($user->profile_multifactor_pin))) {
    form_set_error('name', 'User doesn\'t have a pin in their profile.');
    return;
  }

  // Make sure a phone number exists.
  if(MULTIFACTOR_BRICK_ON_ERROR
     && (!isset($user->profile_multifactor_number) || !numeric($user->profile_multifactor_number))) {
    form_set_error('name', 'User doesn\'t have a phone number in their profile.');
    return;
  }
//////////////////////////////////// END LOAD USER


//////////////////////////////////// LOAD ROLES TO CHECK
  // Check if the user has any roles that have multi-factor enabled.
  $multifactor_roles_to_check = variable_get('multifactor_roles_to_check', array('authenticated user',
                                                                                'admin',
                                                                                'administrator'));
  if (!is_array($multifactor_roles_to_check)) {
    watchdog('multifactor', 'Multifactor: multifactor_roles_to_check must be an array. Check to make sure this
            variable isn\'t modified by strongarm, devel, or in a settings file, to something other then an array.
            The array is valid even if it has only one element and follows the array syntax.');
    // @todo if brick on errors fail here.
    return;
  }

  // 3-way merge between checked roles, possible roles, and users actual roles.
  $valid_roles = array_intersect($multifactor_roles_to_check,
                                 user_roles(TRUE), // Exclude anonymous from list of all possible roles.
                                 $user->roles // Actual user roles...no thanks to the above misnomer.
  );

  // If MULTIFACTOR_BRICK_ON_ERROR is set to TRUE then lock out the user because they could present a potential brute
  // force vector. You might also want to use this in conjunction with MULTIFACTOR_ROLE_AUTHENTICATED_USER_DISABLED
  // set to false which would mean all users will need to have multifactor authentication to login.
  if(MULTIFACTOR_BRICK_ON_ERROR && count($valid_roles) === 0) {
    form_set_error('name', 'User doesn\'t have roles included in multifactor authentication policies and has been
                   blocked from login.');
    return;
  }
//////////////////////////////////// END LOAD ROLES TO CHECK


//////////////////////////////////// MAKE VOIP CALL

  // Setup the initial call.
  $call = new VoipCall();

  // Get the correct script by it's node title and verify it is available - Requires scriptui.
  $script = VoipScript::loadScript('multifactor_get_pin', array('1234'));
  $call->setScript($script);

  // @todo Check number is valid as a pre-req.
  $call->setDestNumber($user->profile_multifactor_number);
  // @todo Verify this isn't needed.
  $call->setDestName('Ben');

  // The return from calling voip_dial will always be true as long as it contacts the service even if the service fails
  // So After calling this we need to check the call status and verify the pin in the result. Only then is it successful.
  $ret = voip_dial($call);
  if (!$ret) {
    watchdog('multifactor',
      'Error queuing the call. Make sure the VOIP Drupal settings are correct and the VOIP Script exists and can be loaded.');
    if(MULTIFACTOR_BRICK_ON_ERROR) {
      form_set_error('name', 'Multifactor Failure.');
      return;
    }
    else {
      return TRUE;
    }
  }
  else {
    watchdog('multifactor', 'Call successful.');
  }

  // @todo None of this might be necessary! Check call->setVar and prompt call backs. See VOIP Drupal docs for details.
  // Wait until call is done.
  while(!$call->isHangup()) {
    watchdog('multifactor', 'Inside while'); 
   break;
  }
  watchdog('multifactor', 'Outside while');

  // Special case for user 1 because this is the ultimate user and in some cases the only user with any power.
  if(MULTIFACTOR_ROLE_USER_1_FAILOVER) {
    /**
     * @todo Implement User1 failover
     * Call a backup admin and require a valid pin.
     * If the second_admin_pin is correct
     *   reset user 1's pin to a random 4 digit number and provide it to the second_admin
     * If the second_admin_pin is incorrect
     *  block user1 and make no further calls on the users behalf.
     */
  }
//////////////////////////////////// END MAKE VOIP CALL
}

/**
 * Call the user
 */

/**
 * Setup the call
 */

/**
 * Get profile data for the user.
 */

/**
 * Hook into the profile fields to setup a pin number.
 */
//user_profile_form($form_state, $account, $category = 'account')

/**
 * Handle the profile form submit values to save the profile pin number
 */
//user_profile_form_submit($form, &$form_state)

/**
 * Provide a report that shows roles that won't be covered by multifactor.
 */


function multifactor_voipscript_get_script_names() {
  return array('multifactor_get_pin',);
}

function multifactor_voipscript_load_script($script_name, $params = NULL) {

  watchdog('multifactor', 'Params: ' . var_export($params[0], TRUE));

  if ($script_name === 'multifactor_get_pin') {
    $script = new VoipScript('multifactor_get_pin');

    $script->addSay(t('Welcome to our office hot line. '));

    $script->addLabel('office_menu');
    $options_menu = t('For sales, dial 1. For customer support, dial 2. For hours of operation, dial 3. To hang up, dial the star key. ');
    $input_options = array(
      '1' => 'sales',
      '*' => 'hang up',
      'i' => 'hang up',
      't' => 'hang up'
    );
    $invalid_msg = t('Invalid option selected.');
    $script->addRunIvrMenu($options_menu, $input_options, $invalid_msg);
    $script->addGoto('%ivr_option_selected');

    $script->addLabel('sales');
    $script->addSay('Sales department');
    $script->addGoto('hang up');

    $script->addLabel('hang up');
    $script->addHangup();

    /*
    $script->addSay('Welcome to Multifactor Authentication.');

    $script->addLabel('pin_menu');
    $prompt = 'Welcome to Multifactor Authentication.';
    $input_options = array (
      $params[0] => 'success',  // The users pin number is the array element...haha ingenious. @todo verify this is secure.
      '*' => 'hang up',         // Random hang up character
      't' => 'hang up',         // used to report timeout situations
      'i' => 'pin_menu'         // Invalid option
    );
    $invalid_msg = 'I\'m sorry I didn\'t recognize your input, please try again. Hahahahaha';
    $script->addRunIvrMenu($prompt, $input_options, $invalid_msg);
    $script->addGoto('%ivr_option_selected');

    $script->addLabel('success');
    $script->addSay('Success, thank you.');
    $script->addHangup();

    $script->addLabel('hang up');
    $script->addSay(t('Thanks so much for calling. Bye bye.'));
    $script->addHangup();
    */
    
    return $script;
  }
}
